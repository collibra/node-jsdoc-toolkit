/**
 * Dynamic tree-styled structure.
 *
 * Copyright Collibra 2012
 * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
 * @module library/uielements/tree
 * @alias Tree
 * @namespace controls
 */
/*global define,require,core,console,alert */
define('library/uielements/tree',
       ['core'],
       function(require, exports, module) {
  "use strict";

  /*************************************
   *           Requirements            *
   *************************************/

  /** @private */
  var core = require('core'),
      j$ = core.libs.get("jquery");

  /*************************************
   *              Private              *
   *************************************/

  /** @private */
  var _tree = {

   /**
    * Properties
    */
    jstree: null,
    select: null,
    node: null,

    EVENT_ALL: 'before.jstree',
    EVENT_INIT_TREE: 'init.jstree',
    EVENT_LOADED_TREE: 'loaded.jstree',
    EVENT_REOPEN_TREE: 'reopen.jstree',
    EVENT_FOCUS_TREE: 'set_focus.jstree',
    EVENT_BLUR_TREE: 'unset_focus.jstree',
    
    EVENT_HOVER_NODE: 'hover_node.jstree',
    EVENT_DEHOVER_NODE: 'dehover_node.jstree',
    EVENT_SELECT_NODE: 'select_node.jstree',
    EVENT_CREATE_NODE: 'open_node.jstree',
    EVENT_REMOVE_NODE: 'remove.jstree',
    EVENT_RENAME_NODE: 'rename.jstree',
    EVENT_OPEN_NODE: 'open_node.jstree',
    EVENT_CLOSE_NODE: 'close_node.jstree',
    EVENT_MOVE_NODE: 'move_node.jstree',
    EVENT_AFTER_OPEN_NODE: 'after_open.jstree',
    EVENT_CUT_NODE: 'cut.jstree',
    EVENT_COPY_NODE: 'copy.jstree',
    EVENT_PASTE_NODE: 'paste.jstree',
    
    SOURCE_REST: 0,
    SOURCE_HTML: 1,
    MOVE_SHIFT: false,
    MOVE_COPY: true,
    MOVE_MULTITREE: "multitree",

    // default set of plugins and configuration to be used
    core_defaults: {
      html_titles: false,
      animation: 200,
      initially_open: [],
      initially_load: [],
      load_open: false,
      open_parents: true,
      notify_plugins: true,
      rtl: false,
      strings: {
        loading : "Loading..",
        new_node : "Rename me"
      }
    },

    plugins_defaults: [
      "themes",
      "types",
      "html_data",
      "json_data",
      "ui",
      "cookies",
      "contextmenu",
      "crrm",
      //"hotkeys",
      "search"
      //"sort",
      //"dnd"
      ],

    plugins: {

      //The themes plugin controls the looks of jstree - without this plugin you will get a functional tree,
      //but it will look just like an ordinary UL list.

      themes: {
        config: {
          theme: "default",
          url: false,
          dots: true,
          icons: true
        },
        init: function() {
        }
      },

      // cookie plugin for autosave tree state
      cookies: {
        // plugin config based on jstree doc
        config: {
          save_opened: "jstree_open",
          save_selected: "jstree_select",
          auto_save: true
        },
        // to be executed when jstree is created with selected plugin
        init: function(tree) {
          // make sure all of nodes have ids
          // auto generate here if not
            core.dom.select(core.dom.select(tree.find("li"))).each(function() {
              var li = core.dom.select(this);
              if (li.attr("id") === "" || li.attr("id") === undefined) {
                li.attr("id", "cookie-autogenerated-id-" + parseInt((Math.random()* new Date().getTime()), 10));
              }
            });
        }
      },
      
      json_data: {
        config: {
          
        }
      },
      
      html_data: {
        config: {
          
        }
      },
      
      // The UI plugin handles selecting, deselecting and hovering tree items.
      ui: {
        config: {
          select_limit: -1,
          select_multiple_modifier: "ctrl",
          select_range_modifier: "shift",
          selected_parent_close: "select_parent",
          selected_parent_open: true,
          select_prev_on_delete: true,
          disable_selecting_children: false,
          initially_select: []
        },
        init:  function() {
        }
      },

      // The dnd plugin enables drag'n'drop support for jstree, also using foreign nodes and drop targets.
      dnd: {
        config: {
          copy_modifier: "ctrl",
          check_timeout: 200,
          open_timeout: 200,
          drop_target: ".jstree-drop",
          drop_check: function (data) {
            return true;
          },
          drop_finish: function (data) {
            //data.o - the object being dragged
            //data.r - the drop target
          },
          drag_target: ".jstree-draggable",
          drag_check: function (data) {
            return {
              after : false,
              before : false,
              inside : true
            };
          },
          drag_finish: function (data) {
            //data.o - the foreign object being dragged
            //data.r - the target node
          }
        },
        init:  function() {
        }
      },

      // types plugin for setting nodes types
      types: {
        config: {
          max_children: 3,
          max_depth: -1,
          valid_children: [ "root" ],
          use_data: true,
          //li nodes are identified by this attribute, (<li rel="root"> will have types["root"] config)
          type_attr: "rel",
          types: {
            "root" : {
              "icon" : { "image" : "http://static.jstree.com/v.1.0rc/_docs/_drive.png" },
              "valid_children" : [ "default" ],
              "max_depth" : 2,
              "hover_node" : false,
              "select_node"  : function () { return false; },
              "open_node" : function () { return false; },
              "close_node"  : function () { return false; },
              "create_node" : function () { return false; },
              "delete_node" : function () { return false; }
            },
            "default" : {
                  "valid_children" : [ "default" ]
            }
          }
        },
        init:  function() {
        }
      },

      // UNIQUE PLUGIN to check/prevents nodes with same titles coexisting
      // (create/move/rename) in the same parent.
      unique: {
        config: {
          "error_callback" : function (n, p, f) {
            alert("Duplicate node `" + n + "` with function `" + f + "` because of "+ p +"!");
          }
        },
        init:  function() {
        }
      },

      // The hotkeys plugin enables keyboard navigation and shortcuts. Depends
      // on the jquery.hotkeys plugin.
      hotkeys: {
        config: {
          initialy_enabled: true,
          // empty to use internal, to disable internal: return false, to
          // overwrite: overwrite

          "del": function() {
            this.remove();
            console.log("node removed");
          }
        },
        init: function() {
        }
      },

      // The search plugin enables searching for nodes whose title contains a
      // given string, works on async trees too.
      // All found nodes get the jstree-search class applied to their contained
      // a nodes -
      // you can use that class to style search results.
      search: {
        config: {
          search_method: "contains",
          show_only_matches: false,
          ajax: false
        },
        init:  function() {
        }
      },

      // The sort enables jstree to automatically sort all nodes using a specified function.
      // This means that when the user creates, renames or moves nodes around - they will automatically sort.
      sort: {
        config: function (a, b) {
          return this.get_text(a, true) > this.get_text(b, true) ? 1 : -1;
        },
        init: function() {
        }
      },

      // The contextmenu plugin enables a contextual menu to be shown,
      // when the user right-clicks a node (or when triggered programatically by the developer)..
      contextmenu: {
        config: {
          show_at_node: true,
          select_node: false
        },
        init:  function() {
        }
      },

      //The CRRM plugin handles creating, renaming, removing and moving nodes by the user.
      crrm: {
        config: {
          input_width_limit: 200,
          move: {
            always_copy: false,
            open_onmove: true,
            default_position: "last",
            check_move: function (m) {
              return true;
            }
          }
        },
        init:  function() {
        }
      }
    },

    /**
     * Methods
     */

    /**
     * @constructor
     */
    _init: function() {
      this.jstree = core.libs.get("jquery").jstree;
    },

    /**
     * @see tree.create
     */
    getRef: function(sel) {
      return _tree.jstree._reference(sel);
    },

    /**
     * @see tree.checkPlugin
     */
    checkPlugin: function(instance, plugin_name, func_name) {
      var plugins_enabled = _tree.jstree._reference(instance).data;
      if (plugins_enabled.hasOwnProperty(plugin_name)) {
        return true;
      } else {
        throw "Plugin '" + plugin_name + "' needs to be added before you can use tree." + func_name + "() function.";
      }
    },

    /**
     * @see tree.create
     */
    createPlugins: function(tree, chosen_config) {
      var config_object = {},
          t_p = null,
          p_name = "";
      core.object.each(chosen_config.plugins, function(p, p_name) {
        if (_tree.plugins.hasOwnProperty(p_name) && _tree.plugins_defaults.indexOf(p_name) !== -1) {
          t_p = _tree.plugins[p_name];
          //run plugin init
          if (core.func.is(t_p.init)) {
            t_p.init(tree);
          }
          // if there are any configuration specified in chosen_config object
          // we need to extend it
          if (chosen_config.hasOwnProperty(p_name)) {
            // extend plugin default config with user plugin config
            config_object[p_name] = core.object.extend(config_object[p_name], chosen_config[p_name]);
          } else {
            // gets defaults plugin config
            config_object[p_name] = core.object.copy(t_p.config);
          }
        }
        t_p = null;
      });
      return config_object;
    },

    /**
     * @see tree.create
     */
    create: function(selector, config_object, onCreate) {
      selector = core.dom.select(selector);

      // if user specify core config lets extend its defaults
      if (config_object.core) {
        config_object.core = core.object.extend(this.core_defaults, config_object.core);
      } else {
        config_object.core = this.core_defaults;
      }
      
      config_object.core.rtl = config_object.rtl;
      config_object.core.initially_open = config_object.nodes.open;
      config_object.core.initially_load = config_object.nodes.load;
      config_object.core.load_open = config_object.nodes.loadOpen;
      
      // if user specify plugin, we will use only those, otherwise those defined
      // in plugins_defaults
      if (!config_object.plugins) {
        config_object.plugins = _tree.plugins_defaults;
      }
      
      // now lets add chosen plugins objects to our config object
      config_object = core.object.extend(config_object, _tree.createPlugins(selector, config_object));

      //ui
      if (config_object.ui) {
        config_object.ui.select_limit = config_object.selectLimit;
      }
      //cookies
      if (config_object.cookies) {
        config_object.cookies.auto_save = config_object.saveState;
      }
      //crrm
      if (config_object.crrm) {
        config_object.crrm.move.enabled = config_object.move.enabled;
        config_object.crrm.move.always_copy = config_object.move.type;
        config_object.crrm.move.check_move = config_object.move.validation;
      }
      
      //only plugin which uses ajax can be enabled at a time.
      //Either html_data or json_data, chosing one removes the other.
      //of course theres no info about it in public docs..
      if (config_object.content.source) {
        //removing json_data
         delete config_object.json_data;
        config_object.plugins.splice(config_object.plugins.indexOf("json_data"), 1);
        
        config_object.html_data.data = config_object.content.html;
      } else {
        //removing html_data
        delete config_object.html_data;
        config_object.plugins.splice(config_object.plugins.indexOf("html_data"), 1);
        
        if (!config_object.json_data.ajax) {
          config_object.json_data.ajax = {};
        }
        
        
        
        if (config_object.content.ajax.data) {
          config_object.json_data.ajax.data = config_object.content.ajax.data;
        }
        config_object.json_data.ajax.url = config_object.content.rest;
        config_object.json_data.ajax.success = config_object.content.ajax.onSuccess;
        config_object.json_data.ajax.error = config_object.content.ajax.onError;
      }
      
      if (!_tree.is(selector)) {
        if (selector.length) {
          
          selector.bind(_tree.EVENT_LOADED_TREE, onCreate);
          
          //-------JSTREE INIT------------
          selector.jstree(config_object);
          //------------------------------

          //add custom class
          selector.addClass(config_object.className);
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * Methods concerning nodes of the jstree
     */

    /**
     * @see tree.node.open
     */
    nodeOpen: function(selector, node, open_all_children) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          if (open_all_children) {
            return _tree.getRef(selector).open_all( node );
          } else {
            return _tree.getRef(selector).open_node( node );
          }
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.close
     */
    nodeClose: function(selector, node, close_all_children) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          if (close_all_children) {
            return _tree.getRef(selector).close_all( node );
          } else {
            return _tree.getRef(selector).close_node( node );
          }
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.remove
     */
    nodeRemove: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).delete_node( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.setJson
     */
    setJson: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).delete_node( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.getJson
     */
    getJson: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).delete_node( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.add
     */
    /*
     * position: "before", "after", "inside", "first", "last"
     * struct: {
     *  attr: {}, //same as jQuery.attr()
     *  state: "open|close",
     *  data: "node_name|{attr:{}, title:{}}"
     * }
     */
    nodeAdd: function(selector, node, position, struct, skip_rename_input) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).create( node, position, struct, false, skip_rename_input);
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.name
     */
    nodeName: function(selector, node, new_name) {
      var ref = _tree.getRef(selector),
          temp_arr_name = [];
      selector = core.dom.select(selector);
      node = core.dom.select(node);

      if (_tree.is(selector)) {
        if (selector.length) {
          if (new_name) {
            core.object.each(node, function(i, n) {
              ref.rename_node(n, new_name);
            });
            return true;
          } else {
            node.each(function() {
              temp_arr_name.push(ref.get_text(core.dom.select(this)));
            });
            return temp_arr_name;
          }
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.renameMode
     */
    nodeRenameMode: function(selector, node) {
      _tree.checkPlugin(selector, "crrm", "nodeRenameMode");
      var ref = _tree.getRef(selector);
      selector = core.dom.select(selector);
      node = core.dom.select(node);

      if (_tree.is(selector)) {
        if (selector.length) {
            ref.rename(node);
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.bind
     */
    nodeListen: function(node, event_type, callback) {
      node = core.dom.select(node);

      if (node.length) {
        node.bind(event_type, callback);
        return true;
      }
      return false;
    },

    /**
     * @see tree.node.unbind
     */
    nodeStopListener: function(node, event_type) {
      node = core.dom.select(node);

      if (node.length) {
        node.unbind(event_type);
        return true;
      }
      return false;
    },

    /**
     * @see tree.node.move
     */
    nodeMove: function(selector, node, ref, position, is_copy, skip_check) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          if (_tree.getRef(selector).get_settings().move.enabled) {
            _tree.getRef(selector).move_node(node, ref, position, is_copy, skip_check);
            return true;
          }
        }
      }
      return false;
    },

    /**
     * @see tree.node.get
     */
    nodeGet: function(selector, node, child) {
      if (node === "roots") {
        return _tree.getRef(selector)._get_children( -1 );
      } else if (node === "all") {
        return core.dom.select(selector + " li");
      }
      selector = core.dom.select(selector);
      
      if (_tree.is(selector)) {
        if (selector.length) {
          if (child === "parent") {
            return _tree.getRef(selector)._get_parent( node );
          } else if (child === "all") {
            return core.dom.select(node).find("li");
          } else if (child === "next") {
            return _tree.getRef(selector)._get_next( node, true);
          } else if (child === "next-all") {
            return _tree.getRef(selector)._get_next( node, false);
          } else if (child === "prev") {
            return _tree.getRef(selector)._get_prev( node, true);
          } else if (child === "prev-all") {
            return _tree.getRef(selector)._get_prev( node, false);
          } else if (child === "first") {
            return core.dom.select(node).find("li:first");
          } else if (child === "last") {
            return core.dom.select(node).find("ul>li:last");
          } else if (child === "verylast") {
            return core.dom.select(node).find("li:last");
          } else if (!isNaN(parseInt(child, 10))) {
            return core.dom.select(node).find("li:eq(" + child + ")");
          } else {
            return _tree.getRef(selector)._get_node( node );
          }
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.isOpen
     */
    nodeIsOpen: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).is_open( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.isLeaf
     */
    nodeIsLeaf: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).is_leaf( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.isSelected
     */
    nodeIsSelected: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).is_selected ( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.sort
     */
    nodeSort: function(selector, node) {
      selector = core.dom.select(selector);
      node = core.dom.select(node);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).sort( node );
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.cut
     */
    nodeCut: function(selector, node) {
      selector = core.dom.select(selector);
      node = core.dom.select(node);
      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).cut( node );
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.copy
     */
    nodeCopy: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).copy( node );
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.node.paste
     */
    nodePaste: function(selector, node) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).paste( node );
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.isFocused
     */
    isFocused: function(selector) {
      selector = core.dom.select(selector);
      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).is_focused();
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.focus
     */
    focus: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).set_focus();
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.blur
     */
    blur: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).unset_focus();
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.lock
     */
    lock: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).lock();
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.unlock
     */
    unlock: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).unlock();
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.expand
     */
    expand: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.nodeOpen(selector, selector, true);
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.collapse
     */
    collapse: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.nodeClose(selector, selector, true);
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.remove
     */
    remove: function(selector, orginal, clear) {
      selector = core.dom.select(selector, orginal, clear);

      if (_tree.is(selector)) {
        if (selector.length) {
          _tree.getRef(selector).destroy();
          if (orginal) {
            selector.off().unbind().remove();
          }
          if (clear) {
            selector.html("");
          }
          return true;
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.isLocked
     */
    isLocked: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).is_locked();
        }
      } else {
        return false;
      }
    },


    /**
     * @see tree.refresh
     */
    refresh: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).refresh();
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.refresh
     */
    is: function(selector) {
      if (core.dom.select(selector).hasClass("jstree")) {
        return true;
      }
      return false;
    },

    /**
     * @see tree.search
     */
    search: function(selector, str, oncomplete) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          if (str) {
            _tree.nodeStopListener(selector, "search.jstree");
            _tree.nodeListen(selector, "search.jstree", function(e, data) {
              oncomplete(e, data);
            });
            return _tree.getRef(selector).search(str);
          } else {
            return _tree.getRef(selector).clear_search();
          }
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.select
     */
    nodeSelect: function(selector, node, mode, force) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          if (node) {
            if (mode) {
              _tree.getRef(selector).select_node(node, force);
              return true;
            } else {
              _tree.getRef(selector).deselect_node(node);
              return true;
            }
          } else {
            _tree.getRef(selector).deselect_all();
            return true;
          }
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.refresh
     */
    getSelected: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).get_selected();
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.rollBack
     */
    rollback: function(selector, rollback_data) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.jstree.rollback(rollback_data);
        }
      } else {
        return false;
      }
    },

    /**
     * @see tree.getRollbackData
     */
    getRollbackData: function(selector) {
      selector = core.dom.select(selector);

      if (_tree.is(selector)) {
        if (selector.length) {
          return _tree.getRef(selector).get_rollback();
        }
      } else {
        return false;
      }
    }
  };

  _tree._init();

  /*************************************
   *               Public              *
   *************************************/

  var Tree = /** @lends Tree */ {

    EVENT_ALL: _tree.EVENT_ALL,
    EVENT_INIT_TREE: _tree.EVENT_INIT_TREE,
    EVENT_LOADED_TREE: _tree.EVENT_LOADED_TREE,
    EVENT_REOPEN_TREE: _tree.EVENT_REOPEN_TREE,
    EVENT_FOCUS_TREE: _tree.EVENT_FOCUS_TREE,
    EVENT_BLUR_TREE: _tree.EVENT_BLUR_TREE,
    
    EVENT_HOVER_NODE: _tree.EVENT_HOVER_NODE,
    EVENT_DEHOVER_NODE: _tree.EVENT_DEHOVER_NODE,
    EVENT_SELECT_NODE: _tree.EVENT_SELECT_NODE,
    EVENT_CREATE_NODE: _tree.EVENT_CREATE_NODE,
    EVENT_REMOVE_NODE: _tree.EVENT_REMOVE_NODE,
    EVENT_RENAME_NODE: _tree.EVENT_RENAME_NODE,
    EVENT_MOVE_NODE: _tree.EVENT_MOVE_NODE,
    
    /**
     * Name of the event which is called when node is open and after opening animation is over.
     */
    EVENT_AFTER_OPEN_NODE: _tree.EVENT_AFTER_OPEN_NODE,
    EVENT_CUT_NODE: _tree.EVENT_CUT_NODE,
    EVENT_COPY_NODE: _tree.EVENT_COPY_NODE,
    EVENT_PASTE_NODE: _tree.EVENT_PASTE_NODE,
    
    /**
     * Name of the event which is called when node is open(when opening animation started).
     */
    EVENT_OPEN_NODE: _tree.EVENT_OPEN_NODE,

    /**
     * Name of the event which is called when node is closed.
     */
    EVENT_CLOSE_NODE: _tree.EVENT_CLOSE_NODE,

    /**
     * Flag that define which source we want to use when fetching Tree data.
     * In this case its REST remote source, which means proper URL need to be provided.
     * Expected data is to be in Json notation.
     */
    SOURCE_REST: _tree.SOURCE_REST,

    /**
     * Flag that define which source we want to use when fetching Tree data.
     * In this case its HTML markup. Html provided needs to contain valid 'li' structure.
     * @example
     * html: "<li id='root'><a href='#'>Root node</a><ul><li><a href='#'>Child node</a></li></ul></li>"
     */
    SOURCE_HTML: _tree.SOURCE_HTML,

    /**
     * Flag that define the way {@link Tree.node.move} works.
     * MOVE_SHIFT force node to be shifted (not copied).
     */
    MOVE_SHIFT: _tree.MOVE_SHIFT,

    /**
     * Flag that define the way {@link Tree.node.move} works.
     * MOVE_COPY force node to be copied (leaving the original node in place).
     */
    MOVE_COPY: _tree.MOVE_COPY,

    /**
     * Flag that define the way {@link Tree.node.move} works.
     * MOVE_MULTITREE only moves between trees will be forced to a copy.
     */
    MOVE_MULTITREE: _tree.MOVE_MULTITREE,

    /*
     * Methods concerning tree and/or nodes
     */

     /**
     * Disable focus on tree.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true if success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    blur: function(tree) {
      return _tree.blur(tree);
    }.defaults(''),

    /**
     * Collapse the tree (closes all nodes).
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true if success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    collapse: function(tree) {
      return _tree.collapse(tree);
    }.defaults(''),

    /**
     * Create a dynamic tree-based structure.
     * Please note that if your options for a given plugin are the same as the defaults
     * you may omit those options or omit the subobject completely (if you do not need to modify the defaults).
     * @param {CoreObj/Selector} input A CoreObj or selector pointing to the input element.
     * @param {Object} [options] Options for the tree.
     *   @option {Array<String>} nodes.open A list of node id's that should be open.
     *   @option {Array<String>} nodes.load A list of node id's of which the children should be preloaded.
     *   @option {Boolean} nodes.loadOpen=false Load the children of the already open nodes (see nodes.open).
     *   @option {Boolean} rtl=false Is reading direction Right-to-Left?
     *   @option {String} content.source=Tree.SOURCE_REST The source where to get the content from. Can be {@link Tree.SOURCE_HTML} or {@link Tree.SOURCE_REST}.
     *   @option {String} content.html='' Specifies the content to load into the container and convert to a tree. A HTML string (or false if not used). Default is false.
     *   @option {String} content.rest='' A URL where to fetch the results of (JSON).
     *   @option {Function} content.ajax.data A function that will be executed in the current tree's scope (this will be the tree instance) and gets the node about to be open as a paramater (or -1 for initial load). Whatever you return in the data function will be sent to the server as data (so for example you can send the node's ID).
     *   @option {Function} content.ajax.url A function that will be executed in the current tree's scope (this will be the tree instance) and gets the node about to be open as a paramater (or -1 for initial load). Whatever you return in the url function will be used as the ajax URL.
     *   @option {Function} content.ajax.onSuccess Success callback. function(data) {}
     *   @option {Function} content.ajax.onError Error callback.
     *   @option {Number} selectLimit=-1 Defines how many nodes can be selected at a given time (-1 means unlimited, 0 means selection is disabled completelly).
     *   @option {Boolean} disableSelection=false Disable the selection of nodes.
     *   @option {String} className='' A custom class name to add to the tree for styling.
     *   @option {String} move.enabled=false Enable moving of nodes within this tree and among different trees.
     *   @option {String} move.type=Tree.MOVE_SHIFT Defines how moves are handled. Can be {@link Tree.MOVE_COPY}, {@link Tree.MOVE_SHIFT} or {@link Tree.MOVE_MULTITREE}.
     *   @option {String} move.validation The callback function enabling you to prevent some moves. function(node) { return true/false; }
     *   @option {Boolean} saveState=true Save the state of the tree to a cookie.
     * @param {Function} onCreate A callback to execute when Tree is loaded. Provide arguments: event(which holds event data) and data(which holds loaded Tree data).
     * @returns {Boolean} True if success, false on failure.
     * @responsibleAPI <a href="mailto:clovis@collibra.com">Clovis Six</a>
     * @responsibleAPI <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     * @responsibleImplementation <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    create: function(selector, options, onCreate) {
      return _tree.create(selector, options, onCreate);
    }.defaults('', {
      nodes: {
        open: [],
        load: [],
        loadOpen: false
      },
      rtl: false,
      content: {
        source: _tree.SOURCE_REST,
        html: '',
        rest: '',
        ajax: false
      },
      selectLimit: -1,
      className: '',
      move: {
        //is this move.enabled also control copy/cut/paste?
        enabled: true,
        type: _tree.MOVE_SHIFT,
        validation: function(node) {return true;}
      },
      saveState: false
      //onCreate(loaded) is here because it specifically need to be assign before
      //tree is actually created. Therefore we cannot use Tree.node.on for this.
    }, function(event, data){}),

    /**
     * Expand the tree(opens all nodes).
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true if success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    expand: function(tree) {
      return _tree.expand(tree);
    }.defaults(''),

    /**
     * Set focus on tree.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true if success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    focus: function(tree) {
      return _tree.focus(tree);
    }.defaults(''),

    /**
     * Return tree state as a rollback object.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns Returns a rollback object.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    getRollBackData: function(tree) {
      return _tree.getRollbackData(tree);
    }.defaults(''),

    /**
     * Return all selected nodes. Selected either by user interaction or by 'select' method.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    getSelected: function(tree) {
      return _tree.getSelected(tree);
    }.defaults(''),

    /**
     * Check if tree has been created for the given SELECT selector.
     * @param {CoreObj/Selector} select Selector of the SELECT element.
     * @returns {Boolean} Returns true when tree is created on selector, false otherwise.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    is: function(select) {
      return _tree.is(select);
    }.defaults(''),

    /**
     * Check if tree is focused.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true when tree is focused, false otherwise.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    isFocused: function(tree) {
      return _tree.isFocused(tree);
    }.defaults(''),

    /**
     * Check if tree is locked.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true when tree is locked, false otherwise.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    isLocked: function(tree) {
      return _tree.isLocked(tree);
    }.defaults(''),

    /**
     * Set tree in lock mode. It becomes unactive(no events etc..).
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true on success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    lock: function(tree) {
      return _tree.lock(tree);
    }.defaults(''),

    /**
     * Regenerate tree(use refresh() when you manually added a dom node to the select).
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true on success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    refresh: function(tree) {
      return _tree.refresh(tree);
    }.defaults(''),

    /**
     * Remove tree from selector(ul list). Can also destroy it completely or clean list content.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @param {Boolean} original Do you want to remove the list tag too?.
     * @param {Boolean} clear The Do you want to clear(remove content) the list tag too?.
     * @returns {Boolean} Returns true on success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    remove: function(tree, original, clear) {
      return _tree.remove(tree, original, clear);
    }.defaults('', false, false),

    /**
     * Return tree to the previous state saved in rollback object.
     * You can get rollback data in few handled events.
     * @example
     * tree.bind("#tree", "failed-action.jstree", function (e, data) {
     *   tree.rollBack("#tree", data.rlbk);
     * });
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true on success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    rollBack: function(tree, rollback_data) {
      return _tree.rollback(tree, rollback_data);
    }.defaults('', {}),

    /**
     * Search tree for specifed string(among nodes titles). Highlight nodes which matches the search string.
     * Can be called asynchronously thats why the result has to be catched with oncomplete callback.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @param {String} str String to search for.
     * @param {Function} oncomplete Callback which is executed when search is done.
     * Provides two objects: event object, data object with results.
     * @returns {Boolean} Returns true on success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    search: function(tree, str, oncomplete) {
      return _tree.search(tree, str, oncomplete);
    }.defaults('', '', function(){}),

    /**
     * Set tree in unlock mode. It becomes active and responsive.
     * @param {CoreObj/Selector} tree Selector of the created tree.
     * @returns {Boolean} Returns true on success, false on failure.
     * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
     */
    unlock: function(tree) {
      return _tree.unlock(tree);
    }.defaults(''),

    /*
     * Methods concerning nodes only
     */

    node: /** @lends node */ {

      /**
       * Object for handling {@link Tree} node specific actions.
       * @namespace controls/Tree
       * @alias node
       */

      /**
       * Add new node in context of given node.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} parentNode Selector of the node where new node should be added.
       * @param {Integer/String} position The position of the newly created node. This can be an element index(0-9)
       * or one of the specified strings: 'before', 'after', 'inside', 'first', 'last'.
       * @param {Object} struct The data for the newly created node. Consists of three keys.
       * @option {Object} attr And object of attributes(same as jQuery.attr()).
       * @option {String} state Node state after adding. Either "open" or "close".
       * @option {Object} data A string or an object. If string it is used as node title, if an object
       * you can specify two keys: attr and title.
       * @param {Boolean} skip_rename_input If false,the node enters rename mode and rename input is shown.
       * @example
       * t.node.add("#demo1", "#phtml_1", "last", {state: "open", data: "new"},true);
       * @returns {CoreObj/Boolean} Returns newly created node or false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      add: function(tree, parentNode, position, struct, skip_rename_input) {
        return _tree.nodeAdd(tree, parentNode, position, struct, skip_rename_input);
      }.defaults('', '', "first", {}, false),

      /**
       * Close the node. Can also collapse node(close all children).
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @param {Boolean} open_all_children Open all children too?
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      close: function(tree, node, close_all_children) {
        return _tree.nodeClose(tree, node, close_all_children);
      }.defaults('', '', false),

      /**
       * Copy node. To be used with tree.node.paste.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      copy: function(tree, node) {
        return _tree.nodeCopy(tree, node);
      }.defaults('', ''),

      /**
       * Cut node. To be used with tree.node.paste.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      cut: function(tree, node) {
        return _tree.nodeCut(tree, node);
      }.defaults('', ''),

      /**
       * Return all the children of specified node(or can return tree roots).
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Either string when getting all tree roots or selector of the tree node.
       * @param {CoreObj/Selector} child Integer or string pointing current node child(or parent).
       * Possible values are: first, last, verylast, parent, all, 0-9, selector, next, next-all, prev, prev-all.
       * @example
       * tree.node.get("#tree", "roots"); //returns all tree first nodes(roots)
       * tree.node.get("#tree", "#node1", "next-all"); //returns next node out of every tree node(can jump out of #node1 children)
       * @returns {CoreObj/Selector} Returns founded nodes as selectors.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      get: function(tree, node, child) {
        return _tree.nodeGet(tree, node, child);
      }.defaults('', 'roots', ''),

      /**
       * Check if specified node is a leaf(has no children, an ending node).
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      isLeaf: function(tree, node) {
        return _tree.nodeIsLeaf(tree, node);
      }.defaults('', ''),

      /**
       * Check if specified node is in open state(is open).
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      isOpen: function(tree, node) {
        return _tree.nodeIsOpen(tree, node);
      }.defaults('', ''),

      /**
       * Move node around tree. Either by copying or cuting.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the tree node(s).
       * @param {CoreObj/Selector} ref Selector of the tree node(s) where node should be moved.
       * @param {Integer/String} position The new position of the moved node. This can be an element index(0-9)
       * or one of the specified strings: before, after, insode, first, last
       * @param {Boolean} is_copy Move by copying?
       * @param {Boolean} skip_check Skip position check before moving?
       * @example
       * tree.node.move("#tree", "#node_to_move", "#node_to_move_to", "first", false, false);
       * Copy node "#node_to_move" to node "#node_to_move_to" at first position, without copy and check.
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      move: function(tree, node, ref, position, is_copy, skip_check) {
        return _tree.nodeMove(tree, node, ref, position, is_copy, skip_check);
      }.defaults('', '', '', 'first', false, false),

      /**
       * Either return node name(if no new name is specified) or set new name.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @param {String} new_name Node new name/title.
       * @returns {Boolean/String} Returns true if success, false on failure or string with current name.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      name: function(tree, node, new_name) {
        return _tree.nodeName(tree, node, new_name);
      }.defaults('', '', false),


      /**
       * Remove event attached to the {@link Tree.node}.
       * @param {CoreObj/Selector} treeNodeSelector Selector of the tree node(s).
       * @param {String} eventType Event type to be released.
       * @returns {Boolean} True if success, false on failure.
       * @responsibleAPI <a href="mailto:clovis@collibra.com">Clovis Six</a>
       * @responsibleImplementation <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      off: function(treeNodeSelector, eventType) {
        return _tree.nodeStopListener(treeNodeSelector, eventType);
      }.defaults('', ''),

      /**
       * Attach a callback to the {Tree.node} which should be triggered for chosen event type.
       * Can be destroyed with {@link Tree.node.off}.
       * Callback provides two object. First is the usual event data object, the second is defined as:
       * @example
       * data: {
       *    "inst" : {} //the actual tree instance ,
       *    "args" : {} //arguments passed to the function,
       *    "rslt" : {} //any data the function passed to the event,
       *    "rlbk" : {} //an optional rollback object - it is not always present
       * }
       * @param {CoreObj/Selector} treeNodeSelector Selector of the tree node(s).
       * @param {String} eventType Event type to be triggered on.
       * Possible values: EVENT_... , mouse events, key events.
       * @param {Function} callback Callback function to executed.
       * @returns {Boolean} Returns true if success, false on failure.
       * @responsibleAPI <a href="mailto:clovis@collibra.com">Clovis Six</a>
       * @responsibleImplementation <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      on: function(treeNodeSelector, eventType, callback) {
        return _tree.nodeListen(treeNodeSelector, eventType, callback);
      }.defaults('', '', function() {}),

      /**
       * Open the node. Can also expand node(opens all children).
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {Boolean} [children=false] Open all children as well?
       * @returns {Boolean} True if success, false on failure.
       * @responsibleAPI <a href="mailto:clovis@collibra.com">Clovis Six</a>
       * @responsibleImplementation <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      open: function(tree, node, children) {
        // It supposed to be tree selector(as a context for that node)
        return _tree.nodeOpen(tree, node, children);
      }.defaults('', '', false),

      /**
       * Paste previously copied/cut node.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node.
       * @returns {Boolean} True on success, false on failure.
       * @responsibleAPI <a href="mailto:clovis@collibra.com">Clovis Six</a>
       * @responsibleImplementation <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      paste: function(tree, node) {
        return _tree.nodePaste(tree, node);
      }.defaults('', ''),

      /**
       * Remove node(s) completely.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node(s).
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      remove: function(tree, node) {
        return _tree.nodeRemove(tree, node);
      }.defaults('', ''),

      /**
       * Set tree in rename mode. Shows input in node title and wait for user response.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node(s).
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      renameMode: function(tree, node) {
        return _tree.nodeRenameMode(tree, node);
      }.defaults('', ''),

      /**
       * Select or deselect node(same as by clicking node).
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node(s).
       * @param {Boolean} mode True to select node, false to deselect it.
       * @param {Boolean} force Should selection be forced? Doesnt check ui.select_limit.
       * @example
       * tree.node.select("#tree", "#node", true); //select node #node
       * tree.node.select("#tree", "#node", false); //deselect node #node
       * tree.node.select("#tree", false); //deselect all nodes
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      select: function(tree, node, mode, force) {
        return _tree.nodeSelect(tree, node, mode, force);
      }.defaults('', '', true, false),

      /**
       * Sort all children by title(perhaps by custom func too?) for current node.
       * @param {CoreObj/Selector} tree Selector of the created {@link Tree}.
       * @param {CoreObj/Selector} node Selector of the node(s).
       * @returns {Boolean} Returns true if success, false on failure.
       * @author <a href="mailto:gkaczan@collibra.com">Grzegorz Kaczan</a>
       */
      sort: function(tree, node) {
        return _tree.nodeSort(tree, node);
      }.defaults('', '')
    }
  };

  return Tree;
});

core.module.alias.add('Tree', 'library/uielements/tree');